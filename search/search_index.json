{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Syscall Monkey \u00b6 TL;DR \u00b6 Syscall Monkey is a next-gen, cloud-native strace : attach and detach processes using ptrace (Linux only) intercept and manipulate their syscalls (block, change arguments, return value) prepare scenarios in a simple yaml format write advanced use cases using syscallmonkey as an SDK Teaser \u00b6 Change the return value \u00b6 Here's how you can trick whoami into thinking it runs as a different user. First, it works as expected: root@f34cc94a6b6d:/# whoami root Use this scenario to always return 1 for the getuid syscall: # cat /examples/getuid-user1.yml rules : - name : switch geteuid to return a different user ID match : name : geteuid modify : return : 1 root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-user1.yml whoami daemon This is because the user number 1 happens to be daemon on my system: root@02a8cb7164ef:/# head -n2 /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin Change an argument of the call \u00b6 How about tricking the process to openat a different file instead? Easy: # cat /examples/openat-etc-passwd.yml rules : - name : trick the program to read a different file, instead of /etc/passwd match : name : openat args : - number : 1 string : \"/etc/passwd\" modify : args : - number : 1 string : \"/tmp/passwd\" root@f34cc94a6b6d:/# whoami root root@bc2f54570070:/# echo \"LOL-HACKED:x:0:0:root:/root:/bin/bash\" > /tmp/passwd root@bc2f54570070:/# monkey -s -c /examples/openat-etc-passwd.yml whoami LOL-HACKED","title":"Home"},{"location":"#welcome-to-syscall-monkey","text":"","title":"Welcome to Syscall Monkey"},{"location":"#tldr","text":"Syscall Monkey is a next-gen, cloud-native strace : attach and detach processes using ptrace (Linux only) intercept and manipulate their syscalls (block, change arguments, return value) prepare scenarios in a simple yaml format write advanced use cases using syscallmonkey as an SDK","title":"TL;DR"},{"location":"#teaser","text":"","title":"Teaser"},{"location":"#change-the-return-value","text":"Here's how you can trick whoami into thinking it runs as a different user. First, it works as expected: root@f34cc94a6b6d:/# whoami root Use this scenario to always return 1 for the getuid syscall: # cat /examples/getuid-user1.yml rules : - name : switch geteuid to return a different user ID match : name : geteuid modify : return : 1 root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-user1.yml whoami daemon This is because the user number 1 happens to be daemon on my system: root@02a8cb7164ef:/# head -n2 /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin","title":"Change the return value"},{"location":"#change-an-argument-of-the-call","text":"How about tricking the process to openat a different file instead? Easy: # cat /examples/openat-etc-passwd.yml rules : - name : trick the program to read a different file, instead of /etc/passwd match : name : openat args : - number : 1 string : \"/etc/passwd\" modify : args : - number : 1 string : \"/tmp/passwd\" root@f34cc94a6b6d:/# whoami root root@bc2f54570070:/# echo \"LOL-HACKED:x:0:0:root:/root:/bin/bash\" > /tmp/passwd root@bc2f54570070:/# monkey -s -c /examples/openat-etc-passwd.yml whoami LOL-HACKED","title":"Change an argument of the call"},{"location":"advanced/","text":"Custom logic in Go \u00b6 Sometimes, you need to build something custom. Syscall Monkey has got you covered! Implementing a custom manipulator \u00b6 It's easy to build a custom binary with a manipulator written in Go. In order to do that, you need to implement the SyscallManipulator interface , and pass an instance to the RunTracer function. It consists of two functions: HandleEntry that's called before a syscall is about to be executed - this is where you can modify the arguments, the syscall code, block the call entirely etc. HandleExit which is where you can modify the return code For every sycall that Syscall Monkey tracer, it will call the two functions in order, and apply any modifications that you request. For example , this silly manipulator will mess the program up by changing all syscalls to getpid and also chaging the return value on every other call: package main import ( \"os\" \"github.com/syscallmonkey/monkey/pkg/config\" \"github.com/syscallmonkey/monkey/pkg/run\" \"github.com/syscallmonkey/monkey/pkg/syscall\" ) // ExampleManipulator does some random stuff, to illustrate what you can do type ExampleManipulator struct { Count int } func ( sm * ExampleManipulator ) HandleEntry ( state syscall . SyscallState ) syscall . SyscallState { // change syscall to always be getpid state . SyscallCode = 102 // and also count the entries sm . Count ++ return state } func ( sm * ExampleManipulator ) HandleExit ( returnValue uint64 ) uint64 { // change the syscall return value on every other call if sm . Count % 2 == 0 { return 0 } return returnValue } func main () { // parse the config (or hardcode them, if you'd like) config := config . ParseCommandLineFlags ( os . Args [ 1 :]) // implement your manipulator m := ExampleManipulator {} // run the tracer run . RunTracer ( config , & m ) } You can hardcode the config, or you can use config.ParseCommandLineFlags(os.Args[1:]) to inherit all the other flags that the regular Syscall Monkey supports.","title":"Advanced Usage"},{"location":"advanced/#custom-logic-in-go","text":"Sometimes, you need to build something custom. Syscall Monkey has got you covered!","title":"Custom logic in Go"},{"location":"advanced/#implementing-a-custom-manipulator","text":"It's easy to build a custom binary with a manipulator written in Go. In order to do that, you need to implement the SyscallManipulator interface , and pass an instance to the RunTracer function. It consists of two functions: HandleEntry that's called before a syscall is about to be executed - this is where you can modify the arguments, the syscall code, block the call entirely etc. HandleExit which is where you can modify the return code For every sycall that Syscall Monkey tracer, it will call the two functions in order, and apply any modifications that you request. For example , this silly manipulator will mess the program up by changing all syscalls to getpid and also chaging the return value on every other call: package main import ( \"os\" \"github.com/syscallmonkey/monkey/pkg/config\" \"github.com/syscallmonkey/monkey/pkg/run\" \"github.com/syscallmonkey/monkey/pkg/syscall\" ) // ExampleManipulator does some random stuff, to illustrate what you can do type ExampleManipulator struct { Count int } func ( sm * ExampleManipulator ) HandleEntry ( state syscall . SyscallState ) syscall . SyscallState { // change syscall to always be getpid state . SyscallCode = 102 // and also count the entries sm . Count ++ return state } func ( sm * ExampleManipulator ) HandleExit ( returnValue uint64 ) uint64 { // change the syscall return value on every other call if sm . Count % 2 == 0 { return 0 } return returnValue } func main () { // parse the config (or hardcode them, if you'd like) config := config . ParseCommandLineFlags ( os . Args [ 1 :]) // implement your manipulator m := ExampleManipulator {} // run the tracer run . RunTracer ( config , & m ) } You can hardcode the config, or you can use config.ParseCommandLineFlags(os.Args[1:]) to inherit all the other flags that the regular Syscall Monkey supports.","title":"Implementing a custom manipulator"},{"location":"getting-started/","text":"Installation \u00b6 Syscall Monkey is written in Go, and there are a few different ways you can get started. Binary \u00b6 You can build the binary from the source: git clone https://github.com/syscallmonkey/monkey.git cd monkey make bin/monkey ./bin/monkey -h Note, that if you're running on MacOS, you can build for Linux, but unfortunately MacOS's version of ptrace doesn't allow any of this magic to happen. Pull Docker container \u00b6 When using with Kubernetes, you can use our official docker images. docker pull ghcr.io/syscallmonkey/monkey:0.0.1rc1 Check the latest available versions here . Note, that these container builds are minimal, and don't include things like bash. $ docker run --rm -ti --cap-add SYS_PTRACE ghcr.io/syscallmonkey/monkey:0.0.1 -h Usage: monkey [ OPTIONS ] Application Options: -p, --attach = Attach to the specified pid -t, --target = Attach to process matching this name -c, --config = Configuration file with desired scenario -o, --output = Write the tracing output to the file ( instead of stdout ) -C, --summary Show verbose debug information -s, --silent Don ' t display tracing info Help Options: -h, --help Show this help message Building Docker container \u00b6 If you're like to build the container locally from the source, it's easy: git clone https://github.com/syscallmonkey/monkey.git cd monkey make build make run make run is a shortcut that will start the newly built image and run a bash session inside: root@3e14fcd5843c:/# monkey -h Usage: monkey [ OPTIONS ] Application Options: -p, --attach = Attach to the specified pid -t, --target = Attach to process matching this name -c, --config = Configuration file with desired scenario -o, --output = Write the tracing output to the file ( instead of stdout ) -C, --summary Show verbose debug information -s, --silent Don ' t display tracing info Help Options: -h, --help Show this help message Compatibility \u00b6 Currently, only Linux on x86_64 is supported. If you need arm support, file an issue. Running Syscall Monkey \u00b6 There are two ways of running Syscall Monkey: start a process (append the command at the end) attach to a running process ( -p flag) Start a new process \u00b6 To start a new process and manipulate it, just append the command at the end of the monkey command. What you're going to see is the list of all syscalls made by the program, printed in the following format: SYSCALL_NAME ( ARG_NAME = ARG_VALUE ) = RETURN_CODE ( OPTIONALLY ERROR DESCRIPTION ) For example, let's see what syscalls a simple sleep 1 makes: root@c69219c773ff:/# monkey sleep 1 Version v0.0.1, build Sat Jul 17 10 :30:03 UTC 2021 Started new process pid 21 execve ( filename = NULL, argv = 0 , envp = 0 ) = 0 brk ( brk = 0 ) = 94331848404992 arch_prctl ( task = 12289 , code = 140722511137424 , addr = 140631102649024 ) = -1 ( errno 22 : invalid argument ) access ( filename = /etc/ld.so.preload, mode = 4 ) = -1 ( errno 2 : no such file or directory ) openat ( dfd = 4294967196 , filename = /etc/ld.so.cache, flags = 524288 , mode = 0 ) = 3 fstat ( fd = 3 , statbuf = 140722511133840 ) = 0 mmap ( addr = 0 , len = 6530 , prot = 1 , flags = 2 , fd = 3 , off = 0 ) = 140631102525440 close ( fd = 3 ) = 0 openat ( dfd = 4294967196 , filename = /lib/x86_64-linux-gnu/libc.so.6, flags = 524288 , mode = 0 ) = 3 read ( fd = 3 , buf = , count = 832 ) = 832 pread64 ( fd = 3 , buf = , count = 784 , pos = 64 ) = 784 pread64 ( fd = 3 , buf = , count = 32 , pos = 848 ) = 32 pread64 ( fd = 3 , buf = , count = 68 , pos = 880 ) = 68 fstat ( fd = 3 , statbuf = 140722511133920 ) = 0 mmap ( addr = 0 , len = 8192 , prot = 3 , flags = 34 , fd = 4294967295 , off = 0 ) = 140631102517248 pread64 ( fd = 3 , buf = , count = 784 , pos = 64 ) = 784 pread64 ( fd = 3 , buf = , count = 32 , pos = 848 ) = 32 pread64 ( fd = 3 , buf = , count = 68 , pos = 880 ) = 68 mmap ( addr = 0 , len = 2036952 , prot = 1 , flags = 2050 , fd = 3 , off = 0 ) = 140631100477440 mprotect ( start = 140631100628992 , len = 1847296 , prot = 0 ) = 0 mmap ( addr = 140631100628992 , len = 1540096 , prot = 5 , flags = 2066 , fd = 3 , off = 151552 ) = 140631100628992 mmap ( addr = 140631102169088 , len = 303104 , prot = 1 , flags = 2066 , fd = 3 , off = 1691648 ) = 140631102169088 mmap ( addr = 140631102476288 , len = 24576 , prot = 3 , flags = 2066 , fd = 3 , off = 1994752 ) = 140631102476288 mmap ( addr = 140631102500864 , len = 13528 , prot = 3 , flags = 50 , fd = 4294967295 , off = 0 ) = 140631102500864 close ( fd = 3 ) = 0 arch_prctl ( task = 4098 , code = 140631102522752 , addr = 18446603442607026496 ) = 0 mprotect ( start = 140631102476288 , len = 12288 , prot = 1 ) = 0 mprotect ( start = 94331820990464 , len = 4096 , prot = 1 ) = 0 mprotect ( start = 140631102717952 , len = 4096 , prot = 1 ) = 0 munmap ( addr = 140631102525440 , len = 6530 ) = 0 brk ( brk = 0 ) = 94331848404992 brk ( brk = 94331848540160 ) = 94331848540160 clock_nanosleep ( which_clock = 0 , flags = 0 , rqtp = 140722511137168 , rmtp = 0 ) = 0 close ( fd = 1 ) = 0 close ( fd = 2 ) = 0 exit_group ( error_code = 0 ) --- program exited --- Let's take a look at an interesting lines. access syscall \u00b6 access syscall check real user's permissions for a file. Its signature is: int access ( const char * pathname , int mode ); In the output, Syscall Monkey intercepted the syscall, and we can see that the program check the file /etc/ld.so.preload , and it gets an error number 2 \"no such file or directory\": access ( filename =/ etc / ld . so . preload , mode = 4 ) = - 1 ( errno 2 : no such file or directory ) Attaching to a running process \u00b6 To attach to a process that's already running, you can specify the PID of the target via -p flag. For example: root@c69219c773ff:/# sleep 5 & [ 1 ] 10 root@c69219c773ff:/# monkey -p 10 ... restart_syscall () = 0 close ( fd = 1 ) = 0 close ( fd = 2 ) = 0 exit_group ( error_code = 0 ) --- program exited --- [ 1 ] + Done sleep 5 Quick start \u00b6 You now have a Syscall Monkey available. Here's a quick example to get you started: Change the return value of geteuid \u00b6 Use this scenario to sometimes change the user returned by getuid : # cat /etc/passwd # root:x:0:0:root:/root:/bin/bash # daemon:x:1:1:daemon:/usr/sbin:/usr/s # bin:x:2:2:bin:/bin:/usr/sbin/nologin # cat /examples/getuid-random.yml rules : - name : probably daemon probability : 0.66 match : name : geteuid modify : return : 1 - name : but maybe bin probability : 0.5 match : name : geteuid modify : return : 2 And this should be enough to confuse a lot of people: root@f34cc94a6b6d:/# whoami root root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-random.yml whoami daemon root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-random.yml whoami root root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-random.yml whoami bin Time for mischief! \u00b6 This should be enough to get you started. Have fun!","title":"Getting Started"},{"location":"getting-started/#installation","text":"Syscall Monkey is written in Go, and there are a few different ways you can get started.","title":"Installation"},{"location":"getting-started/#binary","text":"You can build the binary from the source: git clone https://github.com/syscallmonkey/monkey.git cd monkey make bin/monkey ./bin/monkey -h Note, that if you're running on MacOS, you can build for Linux, but unfortunately MacOS's version of ptrace doesn't allow any of this magic to happen.","title":"Binary"},{"location":"getting-started/#pull-docker-container","text":"When using with Kubernetes, you can use our official docker images. docker pull ghcr.io/syscallmonkey/monkey:0.0.1rc1 Check the latest available versions here . Note, that these container builds are minimal, and don't include things like bash. $ docker run --rm -ti --cap-add SYS_PTRACE ghcr.io/syscallmonkey/monkey:0.0.1 -h Usage: monkey [ OPTIONS ] Application Options: -p, --attach = Attach to the specified pid -t, --target = Attach to process matching this name -c, --config = Configuration file with desired scenario -o, --output = Write the tracing output to the file ( instead of stdout ) -C, --summary Show verbose debug information -s, --silent Don ' t display tracing info Help Options: -h, --help Show this help message","title":"Pull Docker container"},{"location":"getting-started/#building-docker-container","text":"If you're like to build the container locally from the source, it's easy: git clone https://github.com/syscallmonkey/monkey.git cd monkey make build make run make run is a shortcut that will start the newly built image and run a bash session inside: root@3e14fcd5843c:/# monkey -h Usage: monkey [ OPTIONS ] Application Options: -p, --attach = Attach to the specified pid -t, --target = Attach to process matching this name -c, --config = Configuration file with desired scenario -o, --output = Write the tracing output to the file ( instead of stdout ) -C, --summary Show verbose debug information -s, --silent Don ' t display tracing info Help Options: -h, --help Show this help message","title":"Building Docker container"},{"location":"getting-started/#compatibility","text":"Currently, only Linux on x86_64 is supported. If you need arm support, file an issue.","title":"Compatibility"},{"location":"getting-started/#running-syscall-monkey","text":"There are two ways of running Syscall Monkey: start a process (append the command at the end) attach to a running process ( -p flag)","title":"Running Syscall Monkey"},{"location":"getting-started/#start-a-new-process","text":"To start a new process and manipulate it, just append the command at the end of the monkey command. What you're going to see is the list of all syscalls made by the program, printed in the following format: SYSCALL_NAME ( ARG_NAME = ARG_VALUE ) = RETURN_CODE ( OPTIONALLY ERROR DESCRIPTION ) For example, let's see what syscalls a simple sleep 1 makes: root@c69219c773ff:/# monkey sleep 1 Version v0.0.1, build Sat Jul 17 10 :30:03 UTC 2021 Started new process pid 21 execve ( filename = NULL, argv = 0 , envp = 0 ) = 0 brk ( brk = 0 ) = 94331848404992 arch_prctl ( task = 12289 , code = 140722511137424 , addr = 140631102649024 ) = -1 ( errno 22 : invalid argument ) access ( filename = /etc/ld.so.preload, mode = 4 ) = -1 ( errno 2 : no such file or directory ) openat ( dfd = 4294967196 , filename = /etc/ld.so.cache, flags = 524288 , mode = 0 ) = 3 fstat ( fd = 3 , statbuf = 140722511133840 ) = 0 mmap ( addr = 0 , len = 6530 , prot = 1 , flags = 2 , fd = 3 , off = 0 ) = 140631102525440 close ( fd = 3 ) = 0 openat ( dfd = 4294967196 , filename = /lib/x86_64-linux-gnu/libc.so.6, flags = 524288 , mode = 0 ) = 3 read ( fd = 3 , buf = , count = 832 ) = 832 pread64 ( fd = 3 , buf = , count = 784 , pos = 64 ) = 784 pread64 ( fd = 3 , buf = , count = 32 , pos = 848 ) = 32 pread64 ( fd = 3 , buf = , count = 68 , pos = 880 ) = 68 fstat ( fd = 3 , statbuf = 140722511133920 ) = 0 mmap ( addr = 0 , len = 8192 , prot = 3 , flags = 34 , fd = 4294967295 , off = 0 ) = 140631102517248 pread64 ( fd = 3 , buf = , count = 784 , pos = 64 ) = 784 pread64 ( fd = 3 , buf = , count = 32 , pos = 848 ) = 32 pread64 ( fd = 3 , buf = , count = 68 , pos = 880 ) = 68 mmap ( addr = 0 , len = 2036952 , prot = 1 , flags = 2050 , fd = 3 , off = 0 ) = 140631100477440 mprotect ( start = 140631100628992 , len = 1847296 , prot = 0 ) = 0 mmap ( addr = 140631100628992 , len = 1540096 , prot = 5 , flags = 2066 , fd = 3 , off = 151552 ) = 140631100628992 mmap ( addr = 140631102169088 , len = 303104 , prot = 1 , flags = 2066 , fd = 3 , off = 1691648 ) = 140631102169088 mmap ( addr = 140631102476288 , len = 24576 , prot = 3 , flags = 2066 , fd = 3 , off = 1994752 ) = 140631102476288 mmap ( addr = 140631102500864 , len = 13528 , prot = 3 , flags = 50 , fd = 4294967295 , off = 0 ) = 140631102500864 close ( fd = 3 ) = 0 arch_prctl ( task = 4098 , code = 140631102522752 , addr = 18446603442607026496 ) = 0 mprotect ( start = 140631102476288 , len = 12288 , prot = 1 ) = 0 mprotect ( start = 94331820990464 , len = 4096 , prot = 1 ) = 0 mprotect ( start = 140631102717952 , len = 4096 , prot = 1 ) = 0 munmap ( addr = 140631102525440 , len = 6530 ) = 0 brk ( brk = 0 ) = 94331848404992 brk ( brk = 94331848540160 ) = 94331848540160 clock_nanosleep ( which_clock = 0 , flags = 0 , rqtp = 140722511137168 , rmtp = 0 ) = 0 close ( fd = 1 ) = 0 close ( fd = 2 ) = 0 exit_group ( error_code = 0 ) --- program exited --- Let's take a look at an interesting lines.","title":"Start a new process"},{"location":"getting-started/#access-syscall","text":"access syscall check real user's permissions for a file. Its signature is: int access ( const char * pathname , int mode ); In the output, Syscall Monkey intercepted the syscall, and we can see that the program check the file /etc/ld.so.preload , and it gets an error number 2 \"no such file or directory\": access ( filename =/ etc / ld . so . preload , mode = 4 ) = - 1 ( errno 2 : no such file or directory )","title":"access syscall"},{"location":"getting-started/#attaching-to-a-running-process","text":"To attach to a process that's already running, you can specify the PID of the target via -p flag. For example: root@c69219c773ff:/# sleep 5 & [ 1 ] 10 root@c69219c773ff:/# monkey -p 10 ... restart_syscall () = 0 close ( fd = 1 ) = 0 close ( fd = 2 ) = 0 exit_group ( error_code = 0 ) --- program exited --- [ 1 ] + Done sleep 5","title":"Attaching to a running process"},{"location":"getting-started/#quick-start","text":"You now have a Syscall Monkey available. Here's a quick example to get you started:","title":"Quick start"},{"location":"getting-started/#change-the-return-value-of-geteuid","text":"Use this scenario to sometimes change the user returned by getuid : # cat /etc/passwd # root:x:0:0:root:/root:/bin/bash # daemon:x:1:1:daemon:/usr/sbin:/usr/s # bin:x:2:2:bin:/bin:/usr/sbin/nologin # cat /examples/getuid-random.yml rules : - name : probably daemon probability : 0.66 match : name : geteuid modify : return : 1 - name : but maybe bin probability : 0.5 match : name : geteuid modify : return : 2 And this should be enough to confuse a lot of people: root@f34cc94a6b6d:/# whoami root root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-random.yml whoami daemon root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-random.yml whoami root root@f34cc94a6b6d:/# monkey -s -c /examples/getuid-random.yml whoami bin","title":"Change the return value of geteuid"},{"location":"getting-started/#time-for-mischief","text":"This should be enough to get you started. Have fun!","title":"Time for mischief!"}]}